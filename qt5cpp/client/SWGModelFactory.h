/**
 * GraphHopper Directions API
 * You use the GraphHopper Directions API to add route planning, navigation and route optimization to your software. E.g. the Routing API has turn instructions and elevation data and the Route Optimization API solves your logistic problems and supports various constraints like time window and capacity restrictions. Also it is possible to get all distances between all locations with our fast Matrix API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#ifndef ModelFactory_H_
#define ModelFactory_H_


#include "SWGActivity.h"
#include "SWGAddress.h"
#include "SWGAlgorithm.h"
#include "SWGBreak.h"
#include "SWGConfiguration.h"
#include "SWGCostMatrix.h"
#include "SWGCostMatrix_data.h"
#include "SWGCostMatrix_data_info.h"
#include "SWGGHError.h"
#include "SWGGHError_hints.h"
#include "SWGGeocodingLocation.h"
#include "SWGGeocodingPoint.h"
#include "SWGGeocodingResponse.h"
#include "SWGIsochroneResponse.h"
#include "SWGIsochroneResponsePolygon.h"
#include "SWGIsochroneResponsePolygon_geometry.h"
#include "SWGIsochroneResponsePolygon_properties.h"
#include "SWGJobId.h"
#include "SWGLocation.h"
#include "SWGMatrixRequest.h"
#include "SWGMatrixResponse.h"
#include "SWGObjective.h"
#include "SWGRelation.h"
#include "SWGRequest.h"
#include "SWGResponse.h"
#include "SWGResponseCoordinates.h"
#include "SWGResponseCoordinatesArray.h"
#include "SWGResponseInfo.h"
#include "SWGResponseInstruction.h"
#include "SWGResponseInstructions.h"
#include "SWGRoute.h"
#include "SWGRoutePoint.h"
#include "SWGRouteResponse.h"
#include "SWGRouteResponsePath.h"
#include "SWGRouting.h"
#include "SWGService.h"
#include "SWGShipment.h"
#include "SWGSolution.h"
#include "SWGSolution_unassigned.h"
#include "SWGStop.h"
#include "SWGTimeWindow.h"
#include "SWGVehicle.h"
#include "SWGVehicleType.h"

namespace Swagger {

  inline void* create(QString type) {
    if(QString("SWGActivity").compare(type) == 0) {
      return new SWGActivity();
    }
    if(QString("SWGAddress").compare(type) == 0) {
      return new SWGAddress();
    }
    if(QString("SWGAlgorithm").compare(type) == 0) {
      return new SWGAlgorithm();
    }
    if(QString("SWGBreak").compare(type) == 0) {
      return new SWGBreak();
    }
    if(QString("SWGConfiguration").compare(type) == 0) {
      return new SWGConfiguration();
    }
    if(QString("SWGCostMatrix").compare(type) == 0) {
      return new SWGCostMatrix();
    }
    if(QString("SWGCostMatrix_data").compare(type) == 0) {
      return new SWGCostMatrix_data();
    }
    if(QString("SWGCostMatrix_data_info").compare(type) == 0) {
      return new SWGCostMatrix_data_info();
    }
    if(QString("SWGGHError").compare(type) == 0) {
      return new SWGGHError();
    }
    if(QString("SWGGHError_hints").compare(type) == 0) {
      return new SWGGHError_hints();
    }
    if(QString("SWGGeocodingLocation").compare(type) == 0) {
      return new SWGGeocodingLocation();
    }
    if(QString("SWGGeocodingPoint").compare(type) == 0) {
      return new SWGGeocodingPoint();
    }
    if(QString("SWGGeocodingResponse").compare(type) == 0) {
      return new SWGGeocodingResponse();
    }
    if(QString("SWGIsochroneResponse").compare(type) == 0) {
      return new SWGIsochroneResponse();
    }
    if(QString("SWGIsochroneResponsePolygon").compare(type) == 0) {
      return new SWGIsochroneResponsePolygon();
    }
    if(QString("SWGIsochroneResponsePolygon_geometry").compare(type) == 0) {
      return new SWGIsochroneResponsePolygon_geometry();
    }
    if(QString("SWGIsochroneResponsePolygon_properties").compare(type) == 0) {
      return new SWGIsochroneResponsePolygon_properties();
    }
    if(QString("SWGJobId").compare(type) == 0) {
      return new SWGJobId();
    }
    if(QString("SWGLocation").compare(type) == 0) {
      return new SWGLocation();
    }
    if(QString("SWGMatrixRequest").compare(type) == 0) {
      return new SWGMatrixRequest();
    }
    if(QString("SWGMatrixResponse").compare(type) == 0) {
      return new SWGMatrixResponse();
    }
    if(QString("SWGObjective").compare(type) == 0) {
      return new SWGObjective();
    }
    if(QString("SWGRelation").compare(type) == 0) {
      return new SWGRelation();
    }
    if(QString("SWGRequest").compare(type) == 0) {
      return new SWGRequest();
    }
    if(QString("SWGResponse").compare(type) == 0) {
      return new SWGResponse();
    }
    if(QString("SWGResponseCoordinates").compare(type) == 0) {
      return new SWGResponseCoordinates();
    }
    if(QString("SWGResponseCoordinatesArray").compare(type) == 0) {
      return new SWGResponseCoordinatesArray();
    }
    if(QString("SWGResponseInfo").compare(type) == 0) {
      return new SWGResponseInfo();
    }
    if(QString("SWGResponseInstruction").compare(type) == 0) {
      return new SWGResponseInstruction();
    }
    if(QString("SWGResponseInstructions").compare(type) == 0) {
      return new SWGResponseInstructions();
    }
    if(QString("SWGRoute").compare(type) == 0) {
      return new SWGRoute();
    }
    if(QString("SWGRoutePoint").compare(type) == 0) {
      return new SWGRoutePoint();
    }
    if(QString("SWGRouteResponse").compare(type) == 0) {
      return new SWGRouteResponse();
    }
    if(QString("SWGRouteResponsePath").compare(type) == 0) {
      return new SWGRouteResponsePath();
    }
    if(QString("SWGRouting").compare(type) == 0) {
      return new SWGRouting();
    }
    if(QString("SWGService").compare(type) == 0) {
      return new SWGService();
    }
    if(QString("SWGShipment").compare(type) == 0) {
      return new SWGShipment();
    }
    if(QString("SWGSolution").compare(type) == 0) {
      return new SWGSolution();
    }
    if(QString("SWGSolution_unassigned").compare(type) == 0) {
      return new SWGSolution_unassigned();
    }
    if(QString("SWGStop").compare(type) == 0) {
      return new SWGStop();
    }
    if(QString("SWGTimeWindow").compare(type) == 0) {
      return new SWGTimeWindow();
    }
    if(QString("SWGVehicle").compare(type) == 0) {
      return new SWGVehicle();
    }
    if(QString("SWGVehicleType").compare(type) == 0) {
      return new SWGVehicleType();
    }
    
    return nullptr;
  }

  inline void* create(QString json, QString type) {
    void* val = create(type);
    if(val != nullptr) {
      SWGObject* obj = static_cast<SWGObject*>(val);
      return obj->fromJson(json);
    }
    if(type.startsWith("QString")) {
      return new QString();
    }
    return nullptr;
  }

}

#endif /* ModelFactory_H_ */
